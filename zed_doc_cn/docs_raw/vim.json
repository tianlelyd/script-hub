{
  "url": "https://zed.dev/docs/vim.html",
  "title": "Vim Mode | Zed Code Editor Documentation",
  "content": "<main>\n\n<h1 id=\"vim-mode\"><a class=\"header\" href=\"#vim-mode\">Vim Mode</a></h1>\n<p>Zed includes a Vim emulation layer known as \"vim mode\". On this page, you will learn how to turn Zed's vim mode on or off, what tools and commands Zed provides to help you navigate and edit your code, and generally how to make the most of vim mode in Zed.</p>\n<p>You'll learn how to:</p>\n<ul>\n<li>Understand the core differences between Zed's vim mode and traditional Vim</li>\n<li>Enable or disable vim mode</li>\n<li>Make the most of Zed-specific features within vim mode</li>\n<li>Customize vim mode key bindings</li>\n<li>Configure vim mode settings</li>\n</ul>\n<p>Whether you're new to vim mode or an experienced Vim user looking to optimize your Zed experience, this guide will help you harness the full power of modal editing in Zed.</p>\n<h2 id=\"zeds-vim-mode-design\"><a class=\"header\" href=\"#zeds-vim-mode-design\">Zed's vim mode design</a></h2>\n<p>Vim mode tries to offer a familiar experience to Vim users: it replicates the behavior of motions and commands precisely when it makes sense and uses Zed-specific functionality to provide an editing experience that \"just works\" without requiring configuration on your part.</p>\n<p>This includes support for semantic navigation, multiple cursors, or other features usually provided by plugins like surrounding text.</p>\n<p>So, Zed's vim mode does not replicate Vim one-to-one, but it meshes Vim's modal design with Zed's modern features to provide a more fluid experience. It's also configurable, so you can add your own key bindings or override the defaults.</p>\n<h3 id=\"core-differences\"><a class=\"header\" href=\"#core-differences\">Core differences</a></h3>\n<p>There are four types of features in vim mode that use Zed's core functionality, leading to some differences in behavior:</p>\n<ol>\n<li><strong>Motions</strong>: vim mode uses Zed's semantic parsing to tune the behavior of motions per language. For example, in Rust, jumping to matching bracket with <code>%</code> works with the pipe character <code>|</code>. In JavaScript, <code>w</code> considers <code>$</code> to be a word character.</li>\n<li><strong>Visual block selections</strong>: vim mode uses Zed's multiple cursor to emulate visual block selections, making block selections a lot more flexible. For example, anything you insert after a block selection updates on every line in real-time, and you can add or remove cursors anytime.</li>\n<li><strong>Macros</strong>: vim mode uses Zed's recording system for vim macros. So, you can capture and replay more complex actions, like autocompletion.</li>\n<li><strong>Search and replace</strong>: vim mode uses Zed's search system, so, the syntax for regular expressions is slightly different compared to Vim. <a href=\"#regex-differences\">Head to the Regex differences section</a> for details.</li>\n</ol>\n<blockquote>\n<p><strong>Note:</strong> The foundations of Zed's vim mode should already cover many use cases, and we're always looking to improve it. If you find missing features that you rely on in your workflow, please <a href=\"https://github.com/zed-industries/zed/issues\">file an issue on GitHub</a>.</p>\n</blockquote>\n<h2 id=\"enabling-and-disabling-vim-mode\"><a class=\"header\" href=\"#enabling-and-disabling-vim-mode\">Enabling and disabling vim mode</a></h2>\n<p>When you first open Zed, you'll see a checkbox on the welcome screen that allows you to enable vim mode.</p>\n<p>If you missed this, you can toggle vim mode on or off anytime by opening the command palette and using the workspace command <code>toggle vim mode</code>.</p>\n<blockquote>\n<p><strong>Note</strong>: This command toggles the following property in your user settings:</p>\n<pre><code class=\"language-json\">{\n  \"vim_mode\": true\n}\n</code></pre>\n</blockquote>\n<h2 id=\"zed-specific-features\"><a class=\"header\" href=\"#zed-specific-features\">Zed-specific features</a></h2>\n<p>Zed is built on a modern foundation that (among other things) uses tree-sitter and language servers to understand the content of the file you're editing and supports multiple cursors out of the box.</p>\n<p>Vim mode has several \"core Zed\" key bindings that will help you make the most of Zed's specific feature set.</p>\n<h3 id=\"language-server\"><a class=\"header\" href=\"#language-server\">Language server</a></h3>\n<p>The following commands use the language server to help you navigate and refactor your code.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Go to definition</td><td><code>g d</code></td></tr>\n<tr><td>Go to declaration</td><td><code>g D</code></td></tr>\n<tr><td>Go to type definition</td><td><code>g y</code></td></tr>\n<tr><td>Go to implementation</td><td><code>g I</code></td></tr>\n<tr><td>Rename (change definition)</td><td><code>c d</code></td></tr>\n<tr><td>Go to All references to the current word</td><td><code>g A</code></td></tr>\n<tr><td>Find symbol in current file</td><td><code>g s</code></td></tr>\n<tr><td>Find symbol in entire project</td><td><code>g S</code></td></tr>\n<tr><td>Go to next diagnostic</td><td><code>g ]</code> or <code>] d</code></td></tr>\n<tr><td>Go to previous diagnostic</td><td><code>g [</code> or <code>[ d</code></td></tr>\n<tr><td>Show inline error (hover)</td><td><code>g h</code></td></tr>\n<tr><td>Open the code actions menu</td><td><code>g .</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"git\"><a class=\"header\" href=\"#git\">Git</a></h3>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Go to next git change</td><td><code>] c</code></td></tr>\n<tr><td>Go to previous git change</td><td><code>[ c</code></td></tr>\n<tr><td>Expand diff hunk</td><td><code>d o</code></td></tr>\n<tr><td>Toggle staged</td><td><code>d O</code></td></tr>\n<tr><td>Stage and next (in diff view)</td><td><code>d u</code></td></tr>\n<tr><td>Unstage and next (in diff view)</td><td><code>d U</code></td></tr>\n<tr><td>Restore change</td><td><code>d p</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"treesitter\"><a class=\"header\" href=\"#treesitter\">Treesitter</a></h3>\n<p>Treesitter is a powerful tool that Zed uses to understand the structure of your code. Zed provides motions that change the current cursor position, and text objects that can be used as the target of actions.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Go to next/previous method</td><td><code>] m</code> / <code>[ m</code></td></tr>\n<tr><td>Go to next/previous method end</td><td><code>] M</code> / <code>[ M</code></td></tr>\n<tr><td>Go to next/previous section</td><td><code>] ]</code> / <code>[ [</code></td></tr>\n<tr><td>Go to next/previous section end</td><td><code>] [</code> / <code>[ ]</code></td></tr>\n<tr><td>Go to next/previous comment</td><td><code>] /</code>, <code>] *</code> / <code>[ /</code>, <code>[ *</code></td></tr>\n<tr><td>Select a larger syntax node</td><td><code>[ x</code></td></tr>\n<tr><td>Select a smaller syntax node</td><td><code>] x</code></td></tr>\n</tbody></table>\n</div><div class=\"table-wrapper\"><table><thead><tr><th>Text Objects</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Around a class, definition, etc.</td><td><code>a c</code></td></tr>\n<tr><td>Inside a class, definition, etc.</td><td><code>i c</code></td></tr>\n<tr><td>Around a function, method etc.</td><td><code>a f</code></td></tr>\n<tr><td>Inside a function, method, etc.</td><td><code>i f</code></td></tr>\n<tr><td>A comment</td><td><code>g c</code></td></tr>\n<tr><td>An argument, or list item, etc.</td><td><code>i a</code></td></tr>\n<tr><td>An argument, or list item, etc. (including trailing comma)</td><td><code>a a</code></td></tr>\n<tr><td>Around an HTML-like tag</td><td><code>a t</code></td></tr>\n<tr><td>Inside an HTML-like tag</td><td><code>i t</code></td></tr>\n<tr><td>The current indent level, and one line before and after</td><td><code>a I</code></td></tr>\n<tr><td>The current indent level, and one line before</td><td><code>a i</code></td></tr>\n<tr><td>The current indent level</td><td><code>i i</code></td></tr>\n</tbody></table>\n</div>\n<p>Note that the definitions for the targets of the <code>[m</code> family of motions are the same as the\nboundaries defined by <code>af</code>. The targets of the <code>[[</code> are the same as those defined by <code>ac</code>, though\nif there are no classes, then functions are also used. Similarly <code>gc</code> is used to find <code>[ /</code>. <code>g c</code></p>\n<p>The definition of functions, classes and comments is language dependent, and support can be added\nto extensions by adding a [<code>textobjects.scm</code>]. The definition of arguments and tags operates at\nthe tree-sitter level, but looks for certain patterns in the parse tree and is not currently configurable\nper language.</p>\n<h3 id=\"multi-cursor\"><a class=\"header\" href=\"#multi-cursor\">Multi cursor</a></h3>\n<p>These commands help you manage multiple cursors in Zed.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Add a cursor selecting the next copy of the current word</td><td><code>g l</code></td></tr>\n<tr><td>Add a cursor selecting the previous copy of the current word</td><td><code>g L</code></td></tr>\n<tr><td>Skip latest word selection, and add next</td><td><code>g &gt;</code></td></tr>\n<tr><td>Skip latest word selection, and add previous</td><td><code>g &lt;</code></td></tr>\n<tr><td>Add a visual selection for every copy of the current word</td><td><code>g a</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"pane-management\"><a class=\"header\" href=\"#pane-management\">Pane management</a></h3>\n<p>These commands open new panes or jump to specific panes.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Open a project-wide search</td><td><code>g /</code></td></tr>\n<tr><td>Open the current search excerpt</td><td><code>g &lt;space&gt;</code></td></tr>\n<tr><td>Open the current search excerpt in a split</td><td><code>&lt;ctrl-w&gt; &lt;space&gt;</code></td></tr>\n<tr><td>Go to definition in a split</td><td><code>&lt;ctrl-w&gt; g d</code></td></tr>\n<tr><td>Go to type definition in a split</td><td><code>&lt;ctrl-w&gt; g D</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"in-insert-mode\"><a class=\"header\" href=\"#in-insert-mode\">In insert mode</a></h3>\n<p>The following commands help you bring up Zed's completion menu, request a suggestion from GitHub Copilot, or open the inline AI assistant without leaving insert mode.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Open the completion menu</td><td><code>ctrl-x ctrl-o</code></td></tr>\n<tr><td>Request GitHub Copilot suggestion (requires GitHub Copilot to be configured)</td><td><code>ctrl-x ctrl-c</code></td></tr>\n<tr><td>Open the inline AI assistant (requires a configured assistant)</td><td><code>ctrl-x ctrl-a</code></td></tr>\n<tr><td>Open the code actions menu</td><td><code>ctrl-x ctrl-l</code></td></tr>\n<tr><td>Hides all suggestions</td><td><code>ctrl-x ctrl-z</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"supported-plugins\"><a class=\"header\" href=\"#supported-plugins\">Supported plugins</a></h3>\n<p>Zed's vim mode includes some features that are usually provided by very popular plugins in the Vim ecosystem:</p>\n<ul>\n<li>You can surround text objects with <code>ys</code> (yank surround), change surrounding with <code>cs</code>, and delete surrounding with <code>ds</code>.</li>\n<li>You can comment and uncomment selections with <code>gc</code> in visual mode and <code>gcc</code> in normal mode.</li>\n<li>The project panel supports many shortcuts modeled after the Vim plugin <code>netrw</code>: navigation with <code>hjkl</code>, open file with <code>o</code>, open file in a new tab with <code>t</code>, etc.</li>\n<li>You can add key bindings to your keymap to navigate \"camelCase\" names. <a href=\"#optional-key-bindings\">Head down to the Optional key bindings</a> section to learn how.</li>\n<li>You can use <code>gR</code> to do <a href=\"https://github.com/vim-scripts/ReplaceWithRegister\">ReplaceWithRegister</a>.</li>\n<li>You can use <code>cx</code> for <a href=\"https://github.com/tommcdo/vim-exchange\">vim-exchange</a> functionality. Note that it does not have a default binding in visual mode, but you can add one to your keymap (refer to the <a href=\"#optional-key-bindings\">optional key bindings</a> section).</li>\n<li>You can navigate to indent depths relative to your cursor with the <a href=\"https://github.com/jeetsukumaran/vim-indentwise\">indent wise</a> plugin <code>[-</code>, <code>]-</code>, <code>[+</code>, <code>]+</code>, <code>[=</code>, <code>]=</code>.</li>\n<li>You can select quoted text with AnyQuotes and bracketed text with AnyBrackets text objects. Zed also provides MiniQuotes and MiniBrackets which offer alternative selection behavior based on the <a href=\"https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-ai.md\">mini.ai</a> Neovim plugin. See the <a href=\"#quote-and-bracket-text-objects\">Quote and Bracket text objects</a> section below for details.</li>\n<li>You can configure AnyQuotes, AnyBrackets, MiniQuotes, and MiniBrackets text objects for selecting quoted and bracketed text using different selection strategies. See the <a href=\"#any-bracket-functionality\">Any Bracket Functionality</a> section below for details.</li>\n</ul>\n<h3 id=\"any-bracket-functionality\"><a class=\"header\" href=\"#any-bracket-functionality\">Any Bracket Functionality</a></h3>\n<p>Zed offers two different strategies for selecting text surrounded by any quote, or any bracket. These text objects are <strong>not enabled by default</strong> and must be configured in your keymap to be used.</p>\n<h4 id=\"included-characters\"><a class=\"header\" href=\"#included-characters\">Included Characters</a></h4>\n<p>Each text object type works with specific characters:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Text Object</th><th>Characters</th></tr></thead><tbody>\n<tr><td>AnyQuotes/MiniQuotes</td><td>Single quote (<code>'</code>), Double quote (<code>\"</code>), Backtick (<code>`</code>)</td></tr>\n<tr><td>AnyBrackets/MiniBrackets</td><td>Parentheses (<code>()</code>), Square brackets (<code>[]</code>), Curly braces (<code>{}</code>), Angle brackets (<code>&lt;&gt;</code>)</td></tr>\n</tbody></table>\n</div>\n<p>Both \"Any\" and \"Mini\" variants work with the same character sets, but differ in their selection strategy.</p>\n<h4 id=\"anyquotes-and-anybrackets-traditional-vim-behavior\"><a class=\"header\" href=\"#anyquotes-and-anybrackets-traditional-vim-behavior\">AnyQuotes and AnyBrackets (Traditional Vim behavior)</a></h4>\n<p>These text objects implement traditional Vim behavior:</p>\n<ul>\n<li><strong>Selection priority</strong>: Finds the innermost (closest) quotes or brackets first</li>\n<li><strong>Fallback mechanism</strong>: If none are found, falls back to the current line</li>\n<li><strong>Character-based matching</strong>: Focuses solely on open and close characters without considering syntax</li>\n<li><strong>Vanilla Vim similarity</strong>: AnyBrackets matches the behavior of commands like <code>ci&lt;</code>, <code>ci(</code>, etc., in vanilla Vim, including potential edge cases (like considering <code>&gt;</code> in <code>=&gt;</code> as a closing delimiter)</li>\n</ul>\n<h4 id=\"miniquotes-and-minibrackets-miniai-behavior\"><a class=\"header\" href=\"#miniquotes-and-minibrackets-miniai-behavior\">MiniQuotes and MiniBrackets (mini.ai behavior)</a></h4>\n<p>These text objects implement the behavior of the <a href=\"https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-ai.md\">mini.ai</a> Neovim plugin:</p>\n<ul>\n<li><strong>Selection priority</strong>: Searches the current line first before expanding outward</li>\n<li><strong>Tree-sitter integration</strong>: Uses Tree-sitter queries for more context-aware selections</li>\n<li><strong>Syntax-aware matching</strong>: Can distinguish between actual brackets and similar characters in other contexts (like <code>&gt;</code> in <code>=&gt;</code>)</li>\n</ul>\n<h4 id=\"choosing-between-approaches\"><a class=\"header\" href=\"#choosing-between-approaches\">Choosing Between Approaches</a></h4>\n<ul>\n<li>\n<p>Use <strong>AnyQuotes/AnyBrackets</strong> if you:</p>\n<ul>\n<li>Prefer traditional Vim behavior</li>\n<li>Want consistent character-based selection prioritizing innermost delimiters</li>\n<li>Need behavior that closely matches vanilla Vim's text objects</li>\n</ul>\n</li>\n<li>\n<p>Use <strong>MiniQuotes/MiniBrackets</strong> if you:</p>\n<ul>\n<li>Prefer the mini.ai plugin behavior</li>\n<li>Want more context-aware selections using Tree-sitter</li>\n<li>Prefer current-line priority when searching</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"example-configuration\"><a class=\"header\" href=\"#example-configuration\">Example Configuration</a></h4>\n<p>To use these text objects, you need to add bindings to your keymap. Here's an example configuration that makes them available when using text object operators (<code>i</code> and <code>a</code>) or change-surrounds (<code>cs</code>):</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"vim_operator == a || vim_operator == i || vim_operator == cs\",\n  \"bindings\": {\n    // Traditional Vim behavior\n    \"q\": \"vim::AnyQuotes\",\n    \"b\": \"vim::AnyBrackets\",\n\n    // mini.ai plugin behavior\n    \"Q\": \"vim::MiniQuotes\",\n    \"B\": \"vim::MiniBrackets\"\n  }\n}\n</code></pre>\n<p>With this configuration, you can use commands like:</p>\n<ul>\n<li><code>cib</code> - Change inside brackets using AnyBrackets behavior</li>\n<li><code>cim</code> - Change inside brackets using MiniBrackets behavior</li>\n<li><code>ciq</code> - Change inside quotes using AnyQuotes behavior</li>\n<li><code>ciM</code> - Change inside quotes using MiniQuotes behavior</li>\n</ul>\n<h2 id=\"command-palette\"><a class=\"header\" href=\"#command-palette\">Command palette</a></h2>\n<p>Vim mode allows you to open Zed's command palette with <code>:</code>. You can then type to access any usual Zed command. Additionally, vim mode adds aliases for popular Vim commands to ensure your muscle memory transfers to Zed. For example, you can write <code>:w</code> or <code>:write</code> to save the file.</p>\n<p>Below, you'll find tables listing the commands you can use in the command palette. We put optional characters in square brackets to indicate that you can omit them.</p>\n<blockquote>\n<p><strong>Note</strong>: We don't emulate the full power of Vim's command line yet. In particular, commands currently do not support arguments. Please <a href=\"https://github.com/zed-industries/zed\">file issues on GitHub</a> as you find things that are missing from the command palette.</p>\n</blockquote>\n<h3 id=\"file-and-window-management\"><a class=\"header\" href=\"#file-and-window-management\">File and window management</a></h3>\n<p>This table shows commands for managing windows, tabs, and panes. As commands don't support arguments currently, you cannot specify a filename when saving or creating a new file.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:w[rite][!]</code></td><td>Save the current file</td></tr>\n<tr><td><code>:wq[!]</code></td><td>Save the file and close the buffer</td></tr>\n<tr><td><code>:q[uit][!]</code></td><td>Close the buffer</td></tr>\n<tr><td><code>:wa[ll][!]</code></td><td>Save all open files</td></tr>\n<tr><td><code>:wqa[ll][!]</code></td><td>Save all open files and close all buffers</td></tr>\n<tr><td><code>:qa[ll][!]</code></td><td>Close all buffers</td></tr>\n<tr><td><code>:[e]x[it][!]</code></td><td>Close the buffer</td></tr>\n<tr><td><code>:up[date]</code></td><td>Save the current file</td></tr>\n<tr><td><code>:cq</code></td><td>Quit completely (close all running instances of Zed)</td></tr>\n<tr><td><code>:vs[plit]</code></td><td>Split the pane vertically</td></tr>\n<tr><td><code>:sp[lit]</code></td><td>Split the pane horizontally</td></tr>\n<tr><td><code>:new</code></td><td>Create a new file in a horizontal split</td></tr>\n<tr><td><code>:vne[w]</code></td><td>Create a new file in a vertical split</td></tr>\n<tr><td><code>:tabedit</code></td><td>Create a new file in a new tab</td></tr>\n<tr><td><code>:tabnew</code></td><td>Create a new file in a new tab</td></tr>\n<tr><td><code>:tabn[ext]</code></td><td>Go to the next tab</td></tr>\n<tr><td><code>:tabp[rev]</code></td><td>Go to previous tab</td></tr>\n<tr><td><code>:tabc[lose]</code></td><td>Close the current tab</td></tr>\n<tr><td><code>:ls</code></td><td>Show all buffers</td></tr>\n</tbody></table>\n</div>\n<blockquote>\n<p><strong>Note:</strong> The <code>!</code> character is used to force the command to execute without saving changes or prompting before overwriting a file.</p>\n</blockquote>\n<h3 id=\"ex-commands\"><a class=\"header\" href=\"#ex-commands\">Ex commands</a></h3>\n<p>These ex commands open Zed's various panels and windows.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Default Shortcut</th></tr></thead><tbody>\n<tr><td>Open the project panel</td><td><code>:E[xplore]</code></td></tr>\n<tr><td>Open the collaboration panel</td><td><code>:C[ollab]</code></td></tr>\n<tr><td>Open the chat panel</td><td><code>:Ch[at]</code></td></tr>\n<tr><td>Open the AI panel</td><td><code>:A[I]</code></td></tr>\n<tr><td>Open the git panel</td><td><code>:G[it]</code></td></tr>\n<tr><td>Open the debug panel</td><td><code>:D[ebug]</code></td></tr>\n<tr><td>Open the notifications panel</td><td><code>:No[tif]</code></td></tr>\n<tr><td>Open the feedback window</td><td><code>:fe[edback]</code></td></tr>\n<tr><td>Open the diagnostics window</td><td><code>:cl[ist]</code></td></tr>\n<tr><td>Open the terminal</td><td><code>:te[rm]</code></td></tr>\n<tr><td>Open the extensions window</td><td><code>:Ext[ensions]</code></td></tr>\n</tbody></table>\n</div>\n<h3 id=\"navigating-diagnostics\"><a class=\"header\" href=\"#navigating-diagnostics\">Navigating diagnostics</a></h3>\n<p>These commands navigate diagnostics.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:cn[ext]</code> or <code>:ln[ext]</code></td><td>Go to the next diagnostic</td></tr>\n<tr><td><code>:cp[rev]</code> or <code>:lp[rev]</code></td><td>Go to the previous diagnostics</td></tr>\n<tr><td><code>:cc</code> or <code>:ll</code></td><td>Open the errors page</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"git-1\"><a class=\"header\" href=\"#git-1\">Git</a></h3>\n<p>These commands interact with the version control system git.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:dif[fupdate]</code></td><td>View the diff under the cursor (<code>d o</code> in normal mode)</td></tr>\n<tr><td><code>:rev[ert]</code></td><td>Revert the diff under the cursor (<code>d p</code> in normal mode)</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"jump\"><a class=\"header\" href=\"#jump\">Jump</a></h3>\n<p>These commands jump to specific positions in the file.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:&lt;number&gt;</code></td><td>Jump to a line number</td></tr>\n<tr><td><code>:$</code></td><td>Jump to the end of the file</td></tr>\n<tr><td><code>:/foo</code> and <code>:?foo</code></td><td>Jump to next/prev line matching foo</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"replacement\"><a class=\"header\" href=\"#replacement\">Replacement</a></h3>\n<p>This command replaces text. It emulates the substitute command in vim. The substitute command uses regular expressions, and Zed uses a slightly different syntax than vim. You can learn more about Zed's syntax below, <a href=\"#regex-differences\">in the regex differences section</a>. Zed will replace only the first occurrence of the search pattern in the current line. To replace all matches append the <code>g</code> flag.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:[range]s/foo/bar/[g]</code></td><td>Replace instances of foo with bar</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"editing\"><a class=\"header\" href=\"#editing\">Editing</a></h3>\n<p>These commands help you edit text.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:j[oin]</code></td><td>Join the current line</td></tr>\n<tr><td><code>:d[elete][l][p]</code></td><td>Delete the current line</td></tr>\n<tr><td><code>:s[ort] [i]</code></td><td>Sort the current selection (with i, case-insensitively)</td></tr>\n<tr><td><code>:y[ank]</code></td><td>Yank (copy) the current selection or line</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"set\"><a class=\"header\" href=\"#set\">Set</a></h3>\n<p>These commands modify editor options locally for the current buffer.</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>\n<tr><td><code>:se[t] [no]wrap</code></td><td>Lines longer than the width of the window will wrap and displaying continues on the next line</td></tr>\n<tr><td><code>:se[t] [no]nu[mber]</code></td><td>Print the line number in front of each line</td></tr>\n<tr><td><code>:se[t] [no]r[elative]nu[mber]</code></td><td>Changes the displayed number to be relative to the cursor</td></tr>\n</tbody></table>\n</div>\n<h3 id=\"command-mnemonics\"><a class=\"header\" href=\"#command-mnemonics\">Command mnemonics</a></h3>\n<p>As any Zed command is available, you may find that it's helpful to remember mnemonics that run the correct command. For example:</p>\n<ul>\n<li><code>:diffs</code> for \"toggle all hunk diffs\"</li>\n<li><code>:cpp</code> for \"copy path to file\"</li>\n<li><code>:crp</code> for \"copy relative path\"</li>\n<li><code>:reveal</code> for \"reveal in finder\"</li>\n<li><code>:zlog</code> for \"open zed log\"</li>\n<li><code>:clank</code> for \"cancel language server work\"</li>\n</ul>\n<h2 id=\"customizing-key-bindings\"><a class=\"header\" href=\"#customizing-key-bindings\">Customizing key bindings</a></h2>\n<p>In this section, we'll learn how to customize the key bindings of Zed's vim mode. You'll learn:</p>\n<ul>\n<li>How to select the correct context for your new key bindings.</li>\n<li>Useful contexts for vim mode key bindings.</li>\n<li>Common key bindings to customize for extra productivity.</li>\n</ul>\n<h3 id=\"selecting-the-correct-context\"><a class=\"header\" href=\"#selecting-the-correct-context\">Selecting the correct context</a></h3>\n<p>Zed's key bindings are evaluated only when the <code>\"context\"</code> property matches your location in the editor. For example, if you add key bindings to the <code>\"Editor\"</code> context, they will only work when you're editing a file. If you add key bindings to the <code>\"Workspace\"</code> context, they will work everywhere in Zed. Here's an example of a key binding that saves when you're editing a file:</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"Editor\",\n  \"bindings\": {\n    \"ctrl-s\": \"file::Save\"\n  }\n}\n</code></pre>\n<p>Contexts are nested, so when you're editing a file, the context is the <code>\"Editor\"</code> context, which is inside the <code>\"Pane\"</code> context, which is inside the <code>\"Workspace\"</code> context. That's why any key bindings you add to the <code>\"Workspace\"</code> context will work when you're editing a file. Here's an example:</p>\n<pre><code class=\"language-json\">// This key binding will work when you're editing a file. It comes built into Zed by default as the workspace: save command.\n{\n  \"context\": \"Workspace\",\n  \"bindings\": {\n    \"ctrl-s\": \"file::Save\"\n  }\n}\n</code></pre>\n<p>Contexts are expressions. They support boolean operators like <code>&amp;&amp;</code> (and) and <code>||</code> (or). For example, you can use the context <code>\"Editor &amp;&amp; vim_mode == normal\"</code> to create key bindings that only work when you're editing a file <em>and</em> you're in vim's normal mode.</p>\n<p>Vim mode adds several contexts to the <code>\"Editor\"</code> context:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>\n<tr><td>VimControl</td><td>Indicates that vim keybindings should work. Currently an alias for <code>vim_mode == normal || vim_mode == visual || vim_mode == operator</code>, but the definition may change over time</td></tr>\n<tr><td>vim_mode == normal</td><td>Normal mode</td></tr>\n<tr><td>vim_mode == visual</td><td>Visual mode</td></tr>\n<tr><td>vim_mode == insert</td><td>Insert mode</td></tr>\n<tr><td>vim_mode == replace</td><td>Replace mode</td></tr>\n<tr><td>vim_mode == waiting</td><td>Waiting for an arbitrary key (e.g., after typing <code>f</code> or <code>t</code>)</td></tr>\n<tr><td>vim_mode == operator</td><td>Waiting for another binding to trigger (e.g., after typing <code>c</code> or <code>d</code>)</td></tr>\n<tr><td>vim_operator</td><td>Set to <code>none</code> unless <code>vim_mode == operator</code>, in which case it is set to the current operator's default keybinding (e.g., after typing <code>d</code>, <code>vim_operator == d</code>)</td></tr>\n</tbody></table>\n</div>\n<blockquote>\n<p><strong>Note</strong>: Contexts are matched only on one level at a time. So it is possible to use the expression <code>\"Editor &amp;&amp; vim_mode == normal\"</code>, but <code>\"Workspace &amp;&amp; vim_mode == normal\"</code> will never match because we set the vim context at the <code>\"Editor\"</code> level.</p>\n</blockquote>\n<h3 id=\"useful-contexts-for-vim-mode-key-bindings\"><a class=\"header\" href=\"#useful-contexts-for-vim-mode-key-bindings\">Useful contexts for vim mode key bindings</a></h3>\n<p>Here's a template with useful vim mode contexts to help you customize your vim mode key bindings. You can copy it and integrate it into your user keymap.</p>\n<pre><code class=\"language-json\">[\n  {\n    \"context\": \"VimControl &amp;&amp; !menu\",\n    \"bindings\": {\n      // Put key bindings here if you want them to work in normal &amp; visual mode.\n    }\n  },\n  {\n    \"context\": \"vim_mode == normal &amp;&amp; !menu\",\n    \"bindings\": {\n      // \"shift-y\": [\"workspace::SendKeystrokes\", \"y $\"] // Use neovim's yank behavior: yank to end of line.\n    }\n  },\n  {\n    \"context\": \"vim_mode == insert\",\n    \"bindings\": {\n      // \"j k\": \"vim::NormalBefore\" // In insert mode, make jk escape to normal mode.\n    }\n  },\n  {\n    \"context\": \"EmptyPane || SharedScreen\",\n    \"bindings\": {\n      // Put key bindings here (in addition to the context above) if you want them to\n      // work when no editor exists.\n      // \"space f\": \"file_finder::Toggle\"\n    }\n  }\n]\n</code></pre>\n<blockquote>\n<p><strong>Note</strong>: If you would like to emulate Vim's <code>map</code> commands (<code>nmap</code>, etc.), you can use the action <code>workspace::SendKeystrokes</code> in the correct context.</p>\n</blockquote>\n<h3 id=\"optional-key-bindings\"><a class=\"header\" href=\"#optional-key-bindings\">Optional key bindings</a></h3>\n<p>By default, you can navigate between the different files open in the editor with shortcuts like <code>ctrl+w</code> followed by one of <code>hjkl</code> to move to the left, down, up, or right, respectively.</p>\n<p>But you cannot use the same shortcuts to move between all the editor docks (the terminal, project panel, assistant panel, ...). If you want to use the same shortcuts to navigate to the docks, you can add the following key bindings to your user keymap.</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"Dock\",\n  \"bindings\": {\n    \"ctrl-w h\": \"workspace::ActivatePaneLeft\",\n    \"ctrl-w l\": \"workspace::ActivatePaneRight\",\n    \"ctrl-w k\": \"workspace::ActivatePaneUp\",\n    \"ctrl-w j\": \"workspace::ActivatePaneDown\"\n    // ... or other keybindings\n  }\n}\n</code></pre>\n<p>Subword motion, which allows you to navigate and select individual words in camelCase or snake_case, is not enabled by default. To enable it, add these bindings to your keymap.</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"VimControl &amp;&amp; !menu &amp;&amp; vim_mode != operator\",\n  \"bindings\": {\n    \"w\": \"vim::NextSubwordStart\",\n    \"b\": \"vim::PreviousSubwordStart\",\n    \"e\": \"vim::NextSubwordEnd\",\n    \"g e\": \"vim::PreviousSubwordEnd\"\n  }\n}\n</code></pre>\n<p>Vim mode comes with shortcuts to surround the selection in normal mode (<code>ys</code>), but it doesn't have a shortcut to add surrounds in visual mode. By default, <code>shift-s</code> substitutes the selection (erases the text and enters insert mode). To use <code>shift-s</code> to add surrounds in visual mode, you can add the following object to your keymap.</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"vim_mode == visual\",\n  \"bindings\": {\n    \"shift-s\": [\"vim::PushAddSurrounds\", {}]\n  }\n}\n</code></pre>\n<p>In non-modal text editors, cursor navigation typically wraps when moving past line ends. Zed, however, handles this behavior exactly like Vim by default: the cursor stops at line boundaries. If you prefer your cursor to wrap between lines, override these keybindings:</p>\n<pre><code class=\"language-json\">// In VimScript, this would look like this:\n// set whichwrap+=&lt;,&gt;,[,],h,l\n{\n  \"context\": \"VimControl &amp;&amp; !menu\",\n  \"bindings\": {\n    \"left\": \"vim::WrappingLeft\",\n    \"right\": \"vim::WrappingRight\",\n    \"h\": \"vim::WrappingLeft\",\n    \"l\": \"vim::WrappingRight\"\n  }\n}\n</code></pre>\n<p>The <a href=\"https://github.com/justinmk/vim-sneak\">Sneak motion</a> feature allows for quick navigation to any two-character sequence in your text. You can enable it by adding the following keybindings to your keymap. By default, the <code>s</code> key is mapped to <code>vim::Substitute</code>. Adding these bindings will override that behavior, so ensure this change aligns with your workflow preferences.</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"vim_mode == normal || vim_mode == visual\",\n  \"bindings\": {\n    \"s\": \"vim::PushSneak\",\n    \"shift-s\": \"vim::PushSneakBackward\"\n  }\n}\n</code></pre>\n<p>The <a href=\"https://github.com/tommcdo/vim-exchange\">vim-exchange</a> feature does not have a default binding for visual mode, as the <code>shift-x</code> binding conflicts with the default <code>shift-x</code> binding for visual mode (<code>vim::VisualDeleteLine</code>). To assign the default vim-exchange binding, add the following keybinding to your keymap:</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"vim_mode == visual\",\n  \"bindings\": {\n    \"shift-x\": \"vim::Exchange\"\n  }\n}\n</code></pre>\n<h3 id=\"restoring-common-text-editing-keybindings\"><a class=\"header\" href=\"#restoring-common-text-editing-keybindings\">Restoring common text editing keybindings</a></h3>\n<p>If you're using vim mode on Linux or Windows, you may find it overrides keybindings you can't live without: <code>ctrl+v</code> to paste, <code>ctrl+f</code> to search, etc. You can restore them by copying this data into your keymap:</p>\n<pre><code class=\"language-json\">{\n  \"context\": \"Editor &amp;&amp; !menu\",\n  \"bindings\": {\n    \"ctrl-c\": \"editor::Copy\",          // vim default: return to normal mode\n    \"ctrl-x\": \"editor::Cut\",           // vim default: decrement\n    \"ctrl-v\": \"editor::Paste\",         // vim default: visual block mode\n    \"ctrl-y\": \"editor::Undo\",          // vim default: line up\n    \"ctrl-f\": \"buffer_search::Deploy\", // vim default: page down\n    \"ctrl-o\": \"workspace::Open\",       // vim default: go back\n    \"ctrl-s\": \"workspace::Save\",       // vim default: show signature\n    \"ctrl-a\": \"editor::SelectAll\",     // vim default: increment\n  }\n},\n</code></pre>\n<h2 id=\"changing-vim-mode-settings\"><a class=\"header\" href=\"#changing-vim-mode-settings\">Changing vim mode settings</a></h2>\n<p>You can change the following settings to modify vim mode's behavior:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Property</th><th>Description</th><th>Default Value</th></tr></thead><tbody>\n<tr><td>default_mode</td><td>The default mode to start in. One of \"normal\", \"insert\", \"replace\", \"visual\", \"visual_line\", \"visual_block\", \"helix_normal\".</td><td>\"normal\"</td></tr>\n<tr><td>use_system_clipboard</td><td>Determines how system clipboard is used:<br/><ul><li>\"always\": use for all operations</li><li>\"never\": only use when explicitly specified</li><li>\"on_yank\": use for yank operations</li></ul></td><td>\"always\"</td></tr>\n<tr><td>use_multiline_find</td><td>deprecated</td><td></td></tr>\n<tr><td>use_smartcase_find</td><td>If <code>true</code>, <code>f</code> and <code>t</code> motions are case-insensitive when the target letter is lowercase.</td><td>false</td></tr>\n<tr><td>toggle_relative_line_numbers</td><td>If <code>true</code>, line numbers are relative in normal mode and absolute in insert mode, giving you the best of both options.</td><td>false</td></tr>\n<tr><td>custom_digraphs</td><td>An object that allows you to add custom digraphs. Read below for an example.</td><td>{}</td></tr>\n<tr><td>highlight_on_yank_duration</td><td>The duration of the highlight animation(in ms). Set to <code>0</code> to disable</td><td>200</td></tr>\n</tbody></table>\n</div>\n<p>Here's an example of adding a digraph for the zombie emoji. This allows you to type <code>ctrl-k f z</code> to insert a zombie emoji. You can add as many digraphs as you like.</p>\n<pre><code class=\"language-json\">{\n  \"vim\": {\n    \"custom_digraphs\": {\n      \"fz\": \"🧟‍♀️\"\n    }\n  }\n}\n</code></pre>\n<p>Here's an example of these settings changed:</p>\n<pre><code class=\"language-json\">{\n  \"vim\": {\n    \"default_mode\": \"insert\",\n    \"use_system_clipboard\": \"never\",\n    \"use_smartcase_find\": true,\n    \"toggle_relative_line_numbers\": true,\n    \"highlight_on_yank_duration\": 50,\n    \"custom_digraphs\": {\n      \"fz\": \"🧟‍♀️\"\n    }\n  }\n}\n</code></pre>\n<h2 id=\"useful-core-zed-settings-for-vim-mode\"><a class=\"header\" href=\"#useful-core-zed-settings-for-vim-mode\">Useful core Zed settings for vim mode</a></h2>\n<p>Here are a few general Zed settings that can help you fine-tune your Vim experience:</p>\n<div class=\"table-wrapper\"><table><thead><tr><th>Property</th><th>Description</th><th>Default Value</th></tr></thead><tbody>\n<tr><td>cursor_blink</td><td>If <code>true</code>, the cursor blinks.</td><td><code>true</code></td></tr>\n<tr><td>relative_line_numbers</td><td>If <code>true</code>, line numbers in the left gutter are relative to the cursor.</td><td><code>false</code></td></tr>\n<tr><td>scrollbar</td><td>Object that controls the scrollbar display. Set to <code>{ \"show\": \"never\" }</code> to hide the scroll bar.</td><td><code>{ \"show\": \"auto\" }</code></td></tr>\n<tr><td>scroll_beyond_last_line</td><td>If set to <code>\"one_page\"</code>, allows scrolling up to one page beyond the last line. Set to <code>\"off\"</code> to prevent this behavior.</td><td><code>\"one_page\"</code></td></tr>\n<tr><td>vertical_scroll_margin</td><td>The number of lines to keep above or below the cursor when scrolling. Set to <code>0</code> to allow the cursor to go up to the edges of the screen vertically.</td><td><code>3</code></td></tr>\n<tr><td>gutter.line_numbers</td><td>Controls the display of line numbers in the gutter. Set the <code>\"line_numbers\"</code> property to <code>false</code> to hide line numbers.</td><td><code>true</code></td></tr>\n<tr><td>command_aliases</td><td>Object that defines aliases for commands in the command palette. You can use it to define shortcut names for commands you use often. Read below for examples.</td><td><code>{}</code></td></tr>\n</tbody></table>\n</div>\n<p>Here's an example of these settings changed:</p>\n<pre><code class=\"language-json\">{\n  // Disable cursor blink\n  \"cursor_blink\": false,\n  // Use relative line numbers\n  \"relative_line_numbers\": true,\n  // Hide the scroll bar\n  \"scrollbar\": { \"show\": \"never\" },\n  // Prevent the buffer from scrolling beyond the last line\n  \"scroll_beyond_last_line\": \"off\",\n  // Allow the cursor to reach the edges of the screen\n  \"vertical_scroll_margin\": 0,\n  \"gutter\": {\n    // Disable line numbers completely:\n    \"line_numbers\": false\n  },\n  \"command_aliases\": {\n    \"W\": \"w\",\n    \"Wq\": \"wq\",\n    \"Q\": \"q\"\n  }\n}\n</code></pre>\n<p>The <code>command_aliases</code> property is a single object that maps keys or key sequences to vim mode commands. The example above defines multiple aliases: <code>W</code> for <code>w</code>, <code>Wq</code> for <code>wq</code>, and <code>Q</code> for <code>q</code>.</p>\n<h2 id=\"regex-differences\"><a class=\"header\" href=\"#regex-differences\">Regex differences</a></h2>\n<p>Zed uses a different regular expression engine from Vim. This means that you will have to use a different syntax in some cases. Here are the most common differences:</p>\n<ul>\n<li><strong>Capture groups</strong>: Vim uses <code>\\(</code> and <code>\\)</code> to represent capture groups, in Zed these are <code>(</code> and <code>)</code>. On the flip side, in Vim, <code>(</code> and <code>)</code> represent literal parentheses, but in Zed these must be escaped to <code>\\(</code> and <code>\\)</code>.</li>\n<li><strong>Matches</strong>: When replacing, Vim uses the backslash character followed by a number to represent a matched capture group. For example, <code>\\1</code>. Zed uses the dollar sign instead. So, when in Vim you use <code>\\0</code> to represent the entire match, in Zed the syntax is <code>$0</code> instead. Same for numbered capture groups: <code>\\1</code> in Vim is <code>$1</code> in Zed.</li>\n<li><strong>Global option</strong>: By default, in Vim, regex searches only match the first occurrence on a line, and you append <code>/g</code> at the end of your query to find all matches. In Zed, regex searches are global by default.</li>\n<li><strong>Case sensitivity</strong>: Vim uses <code>/i</code> to indicate a case-insensitive search. In Zed you can either write <code>(?i)</code> at the start of the pattern or toggle case-sensitivity with the shortcut <kbd class=\"keybinding\">alt-cmd-c|alt-c</kbd>.</li>\n</ul>\n<blockquote>\n<p><strong>Note</strong>: To help with the transition, the command palette will fix parentheses and replace groups for you when you write a Vim-style substitute command, <code>:%s//</code>. So, Zed will convert <code>%s:/\\(a\\)(b)/\\1/</code> into a search for \"(a)(b)\" and a replacement of \"$1\".</p>\n</blockquote>\n<p>For the full syntax supported by Zed's regex engine <a href=\"https://docs.rs/regex/latest/regex/#syntax\">see the regex crate documentation</a>.</p>\n\n</main>",
  "content_text": "Vim Mode\nZed includes a Vim emulation layer known as \"vim mode\". On this page, you will learn how to turn Zed's vim mode on or off, what tools and commands Zed provides to help you navigate and edit your code, and generally how to make the most of vim mode in Zed.\nYou'll learn how to:\n\nUnderstand the core differences between Zed's vim mode and traditional Vim\nEnable or disable vim mode\nMake the most of Zed-specific features within vim mode\nCustomize vim mode key bindings\nConfigure vim mode settings\n\nWhether you're new to vim mode or an experienced Vim user looking to optimize your Zed experience, this guide will help you harness the full power of modal editing in Zed.\nZed's vim mode design\nVim mode tries to offer a familiar experience to Vim users: it replicates the behavior of motions and commands precisely when it makes sense and uses Zed-specific functionality to provide an editing experience that \"just works\" without requiring configuration on your part.\nThis includes support for semantic navigation, multiple cursors, or other features usually provided by plugins like surrounding text.\nSo, Zed's vim mode does not replicate Vim one-to-one, but it meshes Vim's modal design with Zed's modern features to provide a more fluid experience. It's also configurable, so you can add your own key bindings or override the defaults.\nCore differences\nThere are four types of features in vim mode that use Zed's core functionality, leading to some differences in behavior:\n\nMotions: vim mode uses Zed's semantic parsing to tune the behavior of motions per language. For example, in Rust, jumping to matching bracket with % works with the pipe character |. In JavaScript, w considers $ to be a word character.\nVisual block selections: vim mode uses Zed's multiple cursor to emulate visual block selections, making block selections a lot more flexible. For example, anything you insert after a block selection updates on every line in real-time, and you can add or remove cursors anytime.\nMacros: vim mode uses Zed's recording system for vim macros. So, you can capture and replay more complex actions, like autocompletion.\nSearch and replace: vim mode uses Zed's search system, so, the syntax for regular expressions is slightly different compared to Vim. Head to the Regex differences section for details.\n\n\nNote: The foundations of Zed's vim mode should already cover many use cases, and we're always looking to improve it. If you find missing features that you rely on in your workflow, please file an issue on GitHub.\n\nEnabling and disabling vim mode\nWhen you first open Zed, you'll see a checkbox on the welcome screen that allows you to enable vim mode.\nIf you missed this, you can toggle vim mode on or off anytime by opening the command palette and using the workspace command toggle vim mode.\n\nNote: This command toggles the following property in your user settings:\n{\n  \"vim_mode\": true\n}\n\n\nZed-specific features\nZed is built on a modern foundation that (among other things) uses tree-sitter and language servers to understand the content of the file you're editing and supports multiple cursors out of the box.\nVim mode has several \"core Zed\" key bindings that will help you make the most of Zed's specific feature set.\nLanguage server\nThe following commands use the language server to help you navigate and refactor your code.\nCommandDefault Shortcut\nGo to definitiong d\nGo to declarationg D\nGo to type definitiong y\nGo to implementationg I\nRename (change definition)c d\nGo to All references to the current wordg A\nFind symbol in current fileg s\nFind symbol in entire projectg S\nGo to next diagnosticg ] or ] d\nGo to previous diagnosticg [ or [ d\nShow inline error (hover)g h\nOpen the code actions menug .\n\n\nGit\nCommandDefault Shortcut\nGo to next git change] c\nGo to previous git change[ c\nExpand diff hunkd o\nToggle stagedd O\nStage and next (in diff view)d u\nUnstage and next (in diff view)d U\nRestore changed p\n\n\nTreesitter\nTreesitter is a powerful tool that Zed uses to understand the structure of your code. Zed provides motions that change the current cursor position, and text objects that can be used as the target of actions.\nCommandDefault Shortcut\nGo to next/previous method] m / [ m\nGo to next/previous method end] M / [ M\nGo to next/previous section] ] / [ [\nGo to next/previous section end] [ / [ ]\nGo to next/previous comment] /, ] * / [ /, [ *\nSelect a larger syntax node[ x\nSelect a smaller syntax node] x\n\nText ObjectsDefault Shortcut\nAround a class, definition, etc.a c\nInside a class, definition, etc.i c\nAround a function, method etc.a f\nInside a function, method, etc.i f\nA commentg c\nAn argument, or list item, etc.i a\nAn argument, or list item, etc. (including trailing comma)a a\nAround an HTML-like taga t\nInside an HTML-like tagi t\nThe current indent level, and one line before and aftera I\nThe current indent level, and one line beforea i\nThe current indent leveli i\n\n\nNote that the definitions for the targets of the [m family of motions are the same as the\nboundaries defined by af. The targets of the [[ are the same as those defined by ac, though\nif there are no classes, then functions are also used. Similarly gc is used to find [ /. g c\nThe definition of functions, classes and comments is language dependent, and support can be added\nto extensions by adding a [textobjects.scm]. The definition of arguments and tags operates at\nthe tree-sitter level, but looks for certain patterns in the parse tree and is not currently configurable\nper language.\nMulti cursor\nThese commands help you manage multiple cursors in Zed.\nCommandDefault Shortcut\nAdd a cursor selecting the next copy of the current wordg l\nAdd a cursor selecting the previous copy of the current wordg L\nSkip latest word selection, and add nextg >\nSkip latest word selection, and add previousg <\nAdd a visual selection for every copy of the current wordg a\n\n\nPane management\nThese commands open new panes or jump to specific panes.\nCommandDefault Shortcut\nOpen a project-wide searchg /\nOpen the current search excerptg <space>\nOpen the current search excerpt in a split<ctrl-w> <space>\nGo to definition in a split<ctrl-w> g d\nGo to type definition in a split<ctrl-w> g D\n\n\nIn insert mode\nThe following commands help you bring up Zed's completion menu, request a suggestion from GitHub Copilot, or open the inline AI assistant without leaving insert mode.\nCommandDefault Shortcut\nOpen the completion menuctrl-x ctrl-o\nRequest GitHub Copilot suggestion (requires GitHub Copilot to be configured)ctrl-x ctrl-c\nOpen the inline AI assistant (requires a configured assistant)ctrl-x ctrl-a\nOpen the code actions menuctrl-x ctrl-l\nHides all suggestionsctrl-x ctrl-z\n\n\nSupported plugins\nZed's vim mode includes some features that are usually provided by very popular plugins in the Vim ecosystem:\n\nYou can surround text objects with ys (yank surround), change surrounding with cs, and delete surrounding with ds.\nYou can comment and uncomment selections with gc in visual mode and gcc in normal mode.\nThe project panel supports many shortcuts modeled after the Vim plugin netrw: navigation with hjkl, open file with o, open file in a new tab with t, etc.\nYou can add key bindings to your keymap to navigate \"camelCase\" names. Head down to the Optional key bindings section to learn how.\nYou can use gR to do ReplaceWithRegister.\nYou can use cx for vim-exchange functionality. Note that it does not have a default binding in visual mode, but you can add one to your keymap (refer to the optional key bindings section).\nYou can navigate to indent depths relative to your cursor with the indent wise plugin [-, ]-, [+, ]+, [=, ]=.\nYou can select quoted text with AnyQuotes and bracketed text with AnyBrackets text objects. Zed also provides MiniQuotes and MiniBrackets which offer alternative selection behavior based on the mini.ai Neovim plugin. See the Quote and Bracket text objects section below for details.\nYou can configure AnyQuotes, AnyBrackets, MiniQuotes, and MiniBrackets text objects for selecting quoted and bracketed text using different selection strategies. See the Any Bracket Functionality section below for details.\n\nAny Bracket Functionality\nZed offers two different strategies for selecting text surrounded by any quote, or any bracket. These text objects are not enabled by default and must be configured in your keymap to be used.\nIncluded Characters\nEach text object type works with specific characters:\nText ObjectCharacters\nAnyQuotes/MiniQuotesSingle quote ('), Double quote (\"), Backtick (`)\nAnyBrackets/MiniBracketsParentheses (()), Square brackets ([]), Curly braces ({}), Angle brackets (<>)\n\n\nBoth \"Any\" and \"Mini\" variants work with the same character sets, but differ in their selection strategy.\nAnyQuotes and AnyBrackets (Traditional Vim behavior)\nThese text objects implement traditional Vim behavior:\n\nSelection priority: Finds the innermost (closest) quotes or brackets first\nFallback mechanism: If none are found, falls back to the current line\nCharacter-based matching: Focuses solely on open and close characters without considering syntax\nVanilla Vim similarity: AnyBrackets matches the behavior of commands like ci<, ci(, etc., in vanilla Vim, including potential edge cases (like considering > in => as a closing delimiter)\n\nMiniQuotes and MiniBrackets (mini.ai behavior)\nThese text objects implement the behavior of the mini.ai Neovim plugin:\n\nSelection priority: Searches the current line first before expanding outward\nTree-sitter integration: Uses Tree-sitter queries for more context-aware selections\nSyntax-aware matching: Can distinguish between actual brackets and similar characters in other contexts (like > in =>)\n\nChoosing Between Approaches\n\n\nUse AnyQuotes/AnyBrackets if you:\n\nPrefer traditional Vim behavior\nWant consistent character-based selection prioritizing innermost delimiters\nNeed behavior that closely matches vanilla Vim's text objects\n\n\n\nUse MiniQuotes/MiniBrackets if you:\n\nPrefer the mini.ai plugin behavior\nWant more context-aware selections using Tree-sitter\nPrefer current-line priority when searching\n\n\n\nExample Configuration\nTo use these text objects, you need to add bindings to your keymap. Here's an example configuration that makes them available when using text object operators (i and a) or change-surrounds (cs):\n{\n  \"context\": \"vim_operator == a || vim_operator == i || vim_operator == cs\",\n  \"bindings\": {\n    // Traditional Vim behavior\n    \"q\": \"vim::AnyQuotes\",\n    \"b\": \"vim::AnyBrackets\",\n\n    // mini.ai plugin behavior\n    \"Q\": \"vim::MiniQuotes\",\n    \"B\": \"vim::MiniBrackets\"\n  }\n}\n\nWith this configuration, you can use commands like:\n\ncib - Change inside brackets using AnyBrackets behavior\ncim - Change inside brackets using MiniBrackets behavior\nciq - Change inside quotes using AnyQuotes behavior\nciM - Change inside quotes using MiniQuotes behavior\n\nCommand palette\nVim mode allows you to open Zed's command palette with :. You can then type to access any usual Zed command. Additionally, vim mode adds aliases for popular Vim commands to ensure your muscle memory transfers to Zed. For example, you can write :w or :write to save the file.\nBelow, you'll find tables listing the commands you can use in the command palette. We put optional characters in square brackets to indicate that you can omit them.\n\nNote: We don't emulate the full power of Vim's command line yet. In particular, commands currently do not support arguments. Please file issues on GitHub as you find things that are missing from the command palette.\n\nFile and window management\nThis table shows commands for managing windows, tabs, and panes. As commands don't support arguments currently, you cannot specify a filename when saving or creating a new file.\nCommandDescription\n:w[rite][!]Save the current file\n:wq[!]Save the file and close the buffer\n:q[uit][!]Close the buffer\n:wa[ll][!]Save all open files\n:wqa[ll][!]Save all open files and close all buffers\n:qa[ll][!]Close all buffers\n:[e]x[it][!]Close the buffer\n:up[date]Save the current file\n:cqQuit completely (close all running instances of Zed)\n:vs[plit]Split the pane vertically\n:sp[lit]Split the pane horizontally\n:newCreate a new file in a horizontal split\n:vne[w]Create a new file in a vertical split\n:tabeditCreate a new file in a new tab\n:tabnewCreate a new file in a new tab\n:tabn[ext]Go to the next tab\n:tabp[rev]Go to previous tab\n:tabc[lose]Close the current tab\n:lsShow all buffers\n\n\n\nNote: The ! character is used to force the command to execute without saving changes or prompting before overwriting a file.\n\nEx commands\nThese ex commands open Zed's various panels and windows.\nCommandDefault Shortcut\nOpen the project panel:E[xplore]\nOpen the collaboration panel:C[ollab]\nOpen the chat panel:Ch[at]\nOpen the AI panel:A[I]\nOpen the git panel:G[it]\nOpen the debug panel:D[ebug]\nOpen the notifications panel:No[tif]\nOpen the feedback window:fe[edback]\nOpen the diagnostics window:cl[ist]\nOpen the terminal:te[rm]\nOpen the extensions window:Ext[ensions]\n\n\nNavigating diagnostics\nThese commands navigate diagnostics.\nCommandDescription\n:cn[ext] or :ln[ext]Go to the next diagnostic\n:cp[rev] or :lp[rev]Go to the previous diagnostics\n:cc or :llOpen the errors page\n\n\nGit\nThese commands interact with the version control system git.\nCommandDescription\n:dif[fupdate]View the diff under the cursor (d o in normal mode)\n:rev[ert]Revert the diff under the cursor (d p in normal mode)\n\n\nJump\nThese commands jump to specific positions in the file.\nCommandDescription\n:<number>Jump to a line number\n:$Jump to the end of the file\n:/foo and :?fooJump to next/prev line matching foo\n\n\nReplacement\nThis command replaces text. It emulates the substitute command in vim. The substitute command uses regular expressions, and Zed uses a slightly different syntax than vim. You can learn more about Zed's syntax below, in the regex differences section. Zed will replace only the first occurrence of the search pattern in the current line. To replace all matches append the g flag.\nCommandDescription\n:[range]s/foo/bar/[g]Replace instances of foo with bar\n\n\nEditing\nThese commands help you edit text.\nCommandDescription\n:j[oin]Join the current line\n:d[elete][l][p]Delete the current line\n:s[ort] [i]Sort the current selection (with i, case-insensitively)\n:y[ank]Yank (copy) the current selection or line\n\n\nSet\nThese commands modify editor options locally for the current buffer.\nCommandDescription\n:se[t] [no]wrapLines longer than the width of the window will wrap and displaying continues on the next line\n:se[t] [no]nu[mber]Print the line number in front of each line\n:se[t] [no]r[elative]nu[mber]Changes the displayed number to be relative to the cursor\n\n\nCommand mnemonics\nAs any Zed command is available, you may find that it's helpful to remember mnemonics that run the correct command. For example:\n\n:diffs for \"toggle all hunk diffs\"\n:cpp for \"copy path to file\"\n:crp for \"copy relative path\"\n:reveal for \"reveal in finder\"\n:zlog for \"open zed log\"\n:clank for \"cancel language server work\"\n\nCustomizing key bindings\nIn this section, we'll learn how to customize the key bindings of Zed's vim mode. You'll learn:\n\nHow to select the correct context for your new key bindings.\nUseful contexts for vim mode key bindings.\nCommon key bindings to customize for extra productivity.\n\nSelecting the correct context\nZed's key bindings are evaluated only when the \"context\" property matches your location in the editor. For example, if you add key bindings to the \"Editor\" context, they will only work when you're editing a file. If you add key bindings to the \"Workspace\" context, they will work everywhere in Zed. Here's an example of a key binding that saves when you're editing a file:\n{\n  \"context\": \"Editor\",\n  \"bindings\": {\n    \"ctrl-s\": \"file::Save\"\n  }\n}\n\nContexts are nested, so when you're editing a file, the context is the \"Editor\" context, which is inside the \"Pane\" context, which is inside the \"Workspace\" context. That's why any key bindings you add to the \"Workspace\" context will work when you're editing a file. Here's an example:\n// This key binding will work when you're editing a file. It comes built into Zed by default as the workspace: save command.\n{\n  \"context\": \"Workspace\",\n  \"bindings\": {\n    \"ctrl-s\": \"file::Save\"\n  }\n}\n\nContexts are expressions. They support boolean operators like && (and) and || (or). For example, you can use the context \"Editor && vim_mode == normal\" to create key bindings that only work when you're editing a file and you're in vim's normal mode.\nVim mode adds several contexts to the \"Editor\" context:\nOperatorDescription\nVimControlIndicates that vim keybindings should work. Currently an alias for vim_mode == normal || vim_mode == visual || vim_mode == operator, but the definition may change over time\nvim_mode == normalNormal mode\nvim_mode == visualVisual mode\nvim_mode == insertInsert mode\nvim_mode == replaceReplace mode\nvim_mode == waitingWaiting for an arbitrary key (e.g., after typing f or t)\nvim_mode == operatorWaiting for another binding to trigger (e.g., after typing c or d)\nvim_operatorSet to none unless vim_mode == operator, in which case it is set to the current operator's default keybinding (e.g., after typing d, vim_operator == d)\n\n\n\nNote: Contexts are matched only on one level at a time. So it is possible to use the expression \"Editor && vim_mode == normal\", but \"Workspace && vim_mode == normal\" will never match because we set the vim context at the \"Editor\" level.\n\nUseful contexts for vim mode key bindings\nHere's a template with useful vim mode contexts to help you customize your vim mode key bindings. You can copy it and integrate it into your user keymap.\n[\n  {\n    \"context\": \"VimControl && !menu\",\n    \"bindings\": {\n      // Put key bindings here if you want them to work in normal & visual mode.\n    }\n  },\n  {\n    \"context\": \"vim_mode == normal && !menu\",\n    \"bindings\": {\n      // \"shift-y\": [\"workspace::SendKeystrokes\", \"y $\"] // Use neovim's yank behavior: yank to end of line.\n    }\n  },\n  {\n    \"context\": \"vim_mode == insert\",\n    \"bindings\": {\n      // \"j k\": \"vim::NormalBefore\" // In insert mode, make jk escape to normal mode.\n    }\n  },\n  {\n    \"context\": \"EmptyPane || SharedScreen\",\n    \"bindings\": {\n      // Put key bindings here (in addition to the context above) if you want them to\n      // work when no editor exists.\n      // \"space f\": \"file_finder::Toggle\"\n    }\n  }\n]\n\n\nNote: If you would like to emulate Vim's map commands (nmap, etc.), you can use the action workspace::SendKeystrokes in the correct context.\n\nOptional key bindings\nBy default, you can navigate between the different files open in the editor with shortcuts like ctrl+w followed by one of hjkl to move to the left, down, up, or right, respectively.\nBut you cannot use the same shortcuts to move between all the editor docks (the terminal, project panel, assistant panel, ...). If you want to use the same shortcuts to navigate to the docks, you can add the following key bindings to your user keymap.\n{\n  \"context\": \"Dock\",\n  \"bindings\": {\n    \"ctrl-w h\": \"workspace::ActivatePaneLeft\",\n    \"ctrl-w l\": \"workspace::ActivatePaneRight\",\n    \"ctrl-w k\": \"workspace::ActivatePaneUp\",\n    \"ctrl-w j\": \"workspace::ActivatePaneDown\"\n    // ... or other keybindings\n  }\n}\n\nSubword motion, which allows you to navigate and select individual words in camelCase or snake_case, is not enabled by default. To enable it, add these bindings to your keymap.\n{\n  \"context\": \"VimControl && !menu && vim_mode != operator\",\n  \"bindings\": {\n    \"w\": \"vim::NextSubwordStart\",\n    \"b\": \"vim::PreviousSubwordStart\",\n    \"e\": \"vim::NextSubwordEnd\",\n    \"g e\": \"vim::PreviousSubwordEnd\"\n  }\n}\n\nVim mode comes with shortcuts to surround the selection in normal mode (ys), but it doesn't have a shortcut to add surrounds in visual mode. By default, shift-s substitutes the selection (erases the text and enters insert mode). To use shift-s to add surrounds in visual mode, you can add the following object to your keymap.\n{\n  \"context\": \"vim_mode == visual\",\n  \"bindings\": {\n    \"shift-s\": [\"vim::PushAddSurrounds\", {}]\n  }\n}\n\nIn non-modal text editors, cursor navigation typically wraps when moving past line ends. Zed, however, handles this behavior exactly like Vim by default: the cursor stops at line boundaries. If you prefer your cursor to wrap between lines, override these keybindings:\n// In VimScript, this would look like this:\n// set whichwrap+=<,>,[,],h,l\n{\n  \"context\": \"VimControl && !menu\",\n  \"bindings\": {\n    \"left\": \"vim::WrappingLeft\",\n    \"right\": \"vim::WrappingRight\",\n    \"h\": \"vim::WrappingLeft\",\n    \"l\": \"vim::WrappingRight\"\n  }\n}\n\nThe Sneak motion feature allows for quick navigation to any two-character sequence in your text. You can enable it by adding the following keybindings to your keymap. By default, the s key is mapped to vim::Substitute. Adding these bindings will override that behavior, so ensure this change aligns with your workflow preferences.\n{\n  \"context\": \"vim_mode == normal || vim_mode == visual\",\n  \"bindings\": {\n    \"s\": \"vim::PushSneak\",\n    \"shift-s\": \"vim::PushSneakBackward\"\n  }\n}\n\nThe vim-exchange feature does not have a default binding for visual mode, as the shift-x binding conflicts with the default shift-x binding for visual mode (vim::VisualDeleteLine). To assign the default vim-exchange binding, add the following keybinding to your keymap:\n{\n  \"context\": \"vim_mode == visual\",\n  \"bindings\": {\n    \"shift-x\": \"vim::Exchange\"\n  }\n}\n\nRestoring common text editing keybindings\nIf you're using vim mode on Linux or Windows, you may find it overrides keybindings you can't live without: ctrl+v to paste, ctrl+f to search, etc. You can restore them by copying this data into your keymap:\n{\n  \"context\": \"Editor && !menu\",\n  \"bindings\": {\n    \"ctrl-c\": \"editor::Copy\",          // vim default: return to normal mode\n    \"ctrl-x\": \"editor::Cut\",           // vim default: decrement\n    \"ctrl-v\": \"editor::Paste\",         // vim default: visual block mode\n    \"ctrl-y\": \"editor::Undo\",          // vim default: line up\n    \"ctrl-f\": \"buffer_search::Deploy\", // vim default: page down\n    \"ctrl-o\": \"workspace::Open\",       // vim default: go back\n    \"ctrl-s\": \"workspace::Save\",       // vim default: show signature\n    \"ctrl-a\": \"editor::SelectAll\",     // vim default: increment\n  }\n},\n\nChanging vim mode settings\nYou can change the following settings to modify vim mode's behavior:\nPropertyDescriptionDefault Value\ndefault_modeThe default mode to start in. One of \"normal\", \"insert\", \"replace\", \"visual\", \"visual_line\", \"visual_block\", \"helix_normal\".\"normal\"\nuse_system_clipboardDetermines how system clipboard is used:\"always\": use for all operations\"never\": only use when explicitly specified\"on_yank\": use for yank operations\"always\"\nuse_multiline_finddeprecated\nuse_smartcase_findIf true, f and t motions are case-insensitive when the target letter is lowercase.false\ntoggle_relative_line_numbersIf true, line numbers are relative in normal mode and absolute in insert mode, giving you the best of both options.false\ncustom_digraphsAn object that allows you to add custom digraphs. Read below for an example.{}\nhighlight_on_yank_durationThe duration of the highlight animation(in ms). Set to 0 to disable200\n\n\nHere's an example of adding a digraph for the zombie emoji. This allows you to type ctrl-k f z to insert a zombie emoji. You can add as many digraphs as you like.\n{\n  \"vim\": {\n    \"custom_digraphs\": {\n      \"fz\": \"🧟‍♀️\"\n    }\n  }\n}\n\nHere's an example of these settings changed:\n{\n  \"vim\": {\n    \"default_mode\": \"insert\",\n    \"use_system_clipboard\": \"never\",\n    \"use_smartcase_find\": true,\n    \"toggle_relative_line_numbers\": true,\n    \"highlight_on_yank_duration\": 50,\n    \"custom_digraphs\": {\n      \"fz\": \"🧟‍♀️\"\n    }\n  }\n}\n\nUseful core Zed settings for vim mode\nHere are a few general Zed settings that can help you fine-tune your Vim experience:\nPropertyDescriptionDefault Value\ncursor_blinkIf true, the cursor blinks.true\nrelative_line_numbersIf true, line numbers in the left gutter are relative to the cursor.false\nscrollbarObject that controls the scrollbar display. Set to { \"show\": \"never\" } to hide the scroll bar.{ \"show\": \"auto\" }\nscroll_beyond_last_lineIf set to \"one_page\", allows scrolling up to one page beyond the last line. Set to \"off\" to prevent this behavior.\"one_page\"\nvertical_scroll_marginThe number of lines to keep above or below the cursor when scrolling. Set to 0 to allow the cursor to go up to the edges of the screen vertically.3\ngutter.line_numbersControls the display of line numbers in the gutter. Set the \"line_numbers\" property to false to hide line numbers.true\ncommand_aliasesObject that defines aliases for commands in the command palette. You can use it to define shortcut names for commands you use often. Read below for examples.{}\n\n\nHere's an example of these settings changed:\n{\n  // Disable cursor blink\n  \"cursor_blink\": false,\n  // Use relative line numbers\n  \"relative_line_numbers\": true,\n  // Hide the scroll bar\n  \"scrollbar\": { \"show\": \"never\" },\n  // Prevent the buffer from scrolling beyond the last line\n  \"scroll_beyond_last_line\": \"off\",\n  // Allow the cursor to reach the edges of the screen\n  \"vertical_scroll_margin\": 0,\n  \"gutter\": {\n    // Disable line numbers completely:\n    \"line_numbers\": false\n  },\n  \"command_aliases\": {\n    \"W\": \"w\",\n    \"Wq\": \"wq\",\n    \"Q\": \"q\"\n  }\n}\n\nThe command_aliases property is a single object that maps keys or key sequences to vim mode commands. The example above defines multiple aliases: W for w, Wq for wq, and Q for q.\nRegex differences\nZed uses a different regular expression engine from Vim. This means that you will have to use a different syntax in some cases. Here are the most common differences:\n\nCapture groups: Vim uses \\( and \\) to represent capture groups, in Zed these are ( and ). On the flip side, in Vim, ( and ) represent literal parentheses, but in Zed these must be escaped to \\( and \\).\nMatches: When replacing, Vim uses the backslash character followed by a number to represent a matched capture group. For example, \\1. Zed uses the dollar sign instead. So, when in Vim you use \\0 to represent the entire match, in Zed the syntax is $0 instead. Same for numbered capture groups: \\1 in Vim is $1 in Zed.\nGlobal option: By default, in Vim, regex searches only match the first occurrence on a line, and you append /g at the end of your query to find all matches. In Zed, regex searches are global by default.\nCase sensitivity: Vim uses /i to indicate a case-insensitive search. In Zed you can either write (?i) at the start of the pattern or toggle case-sensitivity with the shortcut alt-cmd-c|alt-c.\n\n\nNote: To help with the transition, the command palette will fix parentheses and replace groups for you when you write a Vim-style substitute command, :%s//. So, Zed will convert %s:/\\(a\\)(b)/\\1/ into a search for \"(a)(b)\" and a replacement of \"$1\".\n\nFor the full syntax supported by Zed's regex engine see the regex crate documentation.",
  "nav_structure": [
    {
      "text": "Getting Started",
      "href": "getting-started.html"
    },
    {
      "text": "Getting Started",
      "href": "getting-started.html"
    },
    {
      "text": "System Requirements",
      "href": "system-requirements.html"
    },
    {
      "text": "Accounts",
      "href": "accounts.html"
    },
    {
      "text": "Linux",
      "href": "linux.html"
    },
    {
      "text": "Windows",
      "href": "windows.html"
    },
    {
      "text": "Telemetry",
      "href": "telemetry.html"
    },
    {
      "text": "Workspace Persistence",
      "href": "workspace-persistence.html"
    },
    {
      "text": "Additional Learning Materials",
      "href": "additional-learning-materials.html"
    },
    {
      "text": "Configuring Zed",
      "href": "configuring-zed.html"
    },
    {
      "text": "Configuring Zed",
      "href": "configuring-zed.html"
    },
    {
      "text": "Configuring Languages",
      "href": "configuring-languages.html"
    },
    {
      "text": "Key bindings",
      "href": "key-bindings.html"
    },
    {
      "text": "All Actions",
      "href": "all-actions.html"
    },
    {
      "text": "Snippets",
      "href": "snippets.html"
    },
    {
      "text": "Themes",
      "href": "themes.html"
    },
    {
      "text": "Icon Themes",
      "href": "icon-themes.html"
    },
    {
      "text": "Visual Customization",
      "href": "visual-customization.html"
    },
    {
      "text": "Vim Mode",
      "href": "vim.html"
    },
    {
      "text": "Helix Mode",
      "href": "helix.html"
    },
    {
      "text": "Multibuffers",
      "href": "multibuffers.html"
    },
    {
      "text": "Multibuffers",
      "href": "multibuffers.html"
    },
    {
      "text": "Outline Panel",
      "href": "outline-panel.html"
    },
    {
      "text": "Code Completions",
      "href": "completions.html"
    },
    {
      "text": "Channels",
      "href": "channels.html"
    },
    {
      "text": "Collaboration",
      "href": "collaboration.html"
    },
    {
      "text": "Git",
      "href": "git.html"
    },
    {
      "text": "Debugger",
      "href": "debugger.html"
    },
    {
      "text": "Diagnostics",
      "href": "diagnostics.html"
    },
    {
      "text": "Tasks",
      "href": "tasks.html"
    },
    {
      "text": "Remote Development",
      "href": "remote-development.html"
    },
    {
      "text": "Environment Variables",
      "href": "environment.html"
    },
    {
      "text": "REPL",
      "href": "repl.html"
    },
    {
      "text": "Overview",
      "href": "ai/overview.html"
    },
    {
      "text": "Overview",
      "href": "ai/overview.html"
    },
    {
      "text": "Agent Panel",
      "href": "ai/agent-panel.html"
    },
    {
      "text": "Tools",
      "href": "ai/tools.html"
    },
    {
      "text": "External Agents",
      "href": "ai/external-agents.html"
    },
    {
      "text": "Inline Assistant",
      "href": "ai/inline-assistant.html"
    },
    {
      "text": "Edit Prediction",
      "href": "ai/edit-prediction.html"
    },
    {
      "text": "Text Threads",
      "href": "ai/text-threads.html"
    },
    {
      "text": "Rules",
      "href": "ai/rules.html"
    },
    {
      "text": "Model Context Protocol",
      "href": "ai/mcp.html"
    },
    {
      "text": "Configuration",
      "href": "ai/configuration.html"
    },
    {
      "text": "LLM Providers",
      "href": "ai/llm-providers.html"
    },
    {
      "text": "Agent Settings",
      "href": "ai/agent-settings.html"
    },
    {
      "text": "Subscription",
      "href": "ai/subscription.html"
    },
    {
      "text": "Plans and Usage",
      "href": "ai/plans-and-usage.html"
    },
    {
      "text": "Billing",
      "href": "ai/billing.html"
    },
    {
      "text": "Models",
      "href": "ai/models.html"
    },
    {
      "text": "Privacy and Security",
      "href": "ai/privacy-and-security.html"
    },
    {
      "text": "AI Improvement",
      "href": "ai/ai-improvement.html"
    },
    {
      "text": "Overview",
      "href": "extensions.html"
    },
    {
      "text": "Overview",
      "href": "extensions.html"
    },
    {
      "text": "Installing Extensions",
      "href": "extensions/installing-extensions.html"
    },
    {
      "text": "Developing Extensions",
      "href": "extensions/developing-extensions.html"
    },
    {
      "text": "Language Extensions",
      "href": "extensions/languages.html"
    },
    {
      "text": "Debugger Extensions",
      "href": "extensions/debugger-extensions.html"
    },
    {
      "text": "Theme Extensions",
      "href": "extensions/themes.html"
    },
    {
      "text": "Icon Theme Extensions",
      "href": "extensions/icon-themes.html"
    },
    {
      "text": "Slash Command Extensions",
      "href": "extensions/slash-commands.html"
    },
    {
      "text": "MCP Server Extensions",
      "href": "extensions/mcp-extensions.html"
    },
    {
      "text": "All Languages",
      "href": "languages.html"
    },
    {
      "text": "All Languages",
      "href": "languages.html"
    },
    {
      "text": "Ansible",
      "href": "languages/ansible.html"
    },
    {
      "text": "AsciiDoc",
      "href": "languages/asciidoc.html"
    },
    {
      "text": "Astro",
      "href": "languages/astro.html"
    },
    {
      "text": "Bash",
      "href": "languages/bash.html"
    },
    {
      "text": "Biome",
      "href": "languages/biome.html"
    },
    {
      "text": "C",
      "href": "languages/c.html"
    },
    {
      "text": "C++",
      "href": "languages/cpp.html"
    },
    {
      "text": "C#",
      "href": "languages/csharp.html"
    },
    {
      "text": "Clojure",
      "href": "languages/clojure.html"
    },
    {
      "text": "CSS",
      "href": "languages/css.html"
    },
    {
      "text": "Dart",
      "href": "languages/dart.html"
    },
    {
      "text": "Deno",
      "href": "languages/deno.html"
    },
    {
      "text": "Diff",
      "href": "languages/diff.html"
    },
    {
      "text": "Docker",
      "href": "languages/docker.html"
    },
    {
      "text": "Elixir",
      "href": "languages/elixir.html"
    },
    {
      "text": "Elm",
      "href": "languages/elm.html"
    },
    {
      "text": "Emmet",
      "href": "languages/emmet.html"
    },
    {
      "text": "Erlang",
      "href": "languages/erlang.html"
    },
    {
      "text": "Fish",
      "href": "languages/fish.html"
    },
    {
      "text": "GDScript",
      "href": "languages/gdscript.html"
    },
    {
      "text": "Gleam",
      "href": "languages/gleam.html"
    },
    {
      "text": "GLSL",
      "href": "languages/glsl.html"
    },
    {
      "text": "Go",
      "href": "languages/go.html"
    },
    {
      "text": "Groovy",
      "href": "languages/groovy.html"
    },
    {
      "text": "Haskell",
      "href": "languages/haskell.html"
    },
    {
      "text": "Helm",
      "href": "languages/helm.html"
    },
    {
      "text": "HTML",
      "href": "languages/html.html"
    },
    {
      "text": "Java",
      "href": "languages/java.html"
    },
    {
      "text": "JavaScript",
      "href": "languages/javascript.html"
    },
    {
      "text": "Julia",
      "href": "languages/julia.html"
    },
    {
      "text": "JSON",
      "href": "languages/json.html"
    },
    {
      "text": "Jsonnet",
      "href": "languages/jsonnet.html"
    },
    {
      "text": "Kotlin",
      "href": "languages/kotlin.html"
    },
    {
      "text": "Lua",
      "href": "languages/lua.html"
    },
    {
      "text": "Luau",
      "href": "languages/luau.html"
    },
    {
      "text": "Makefile",
      "href": "languages/makefile.html"
    },
    {
      "text": "Markdown",
      "href": "languages/markdown.html"
    },
    {
      "text": "Nim",
      "href": "languages/nim.html"
    },
    {
      "text": "OCaml",
      "href": "languages/ocaml.html"
    },
    {
      "text": "PHP",
      "href": "languages/php.html"
    },
    {
      "text": "PowerShell",
      "href": "languages/powershell.html"
    },
    {
      "text": "Prisma",
      "href": "languages/prisma.html"
    },
    {
      "text": "Proto",
      "href": "languages/proto.html"
    },
    {
      "text": "PureScript",
      "href": "languages/purescript.html"
    },
    {
      "text": "Python",
      "href": "languages/python.html"
    },
    {
      "text": "R",
      "href": "languages/r.html"
    },
    {
      "text": "Rego",
      "href": "languages/rego.html"
    },
    {
      "text": "ReStructuredText",
      "href": "languages/rst.html"
    },
    {
      "text": "Racket",
      "href": "languages/racket.html"
    },
    {
      "text": "Roc",
      "href": "languages/roc.html"
    },
    {
      "text": "Ruby",
      "href": "languages/ruby.html"
    },
    {
      "text": "Rust",
      "href": "languages/rust.html"
    },
    {
      "text": "Scala",
      "href": "languages/scala.html"
    },
    {
      "text": "Scheme",
      "href": "languages/scheme.html"
    },
    {
      "text": "Shell Script",
      "href": "languages/sh.html"
    },
    {
      "text": "SQL",
      "href": "languages/sql.html"
    },
    {
      "text": "Svelte",
      "href": "languages/svelte.html"
    },
    {
      "text": "Swift",
      "href": "languages/swift.html"
    },
    {
      "text": "Tailwind CSS",
      "href": "languages/tailwindcss.html"
    },
    {
      "text": "Terraform",
      "href": "languages/terraform.html"
    },
    {
      "text": "TOML",
      "href": "languages/toml.html"
    },
    {
      "text": "TypeScript",
      "href": "languages/typescript.html"
    },
    {
      "text": "Uiua",
      "href": "languages/uiua.html"
    },
    {
      "text": "Vue",
      "href": "languages/vue.html"
    },
    {
      "text": "XML",
      "href": "languages/xml.html"
    },
    {
      "text": "YAML",
      "href": "languages/yaml.html"
    },
    {
      "text": "Yara",
      "href": "languages/yara.html"
    },
    {
      "text": "Yarn",
      "href": "languages/yarn.html"
    },
    {
      "text": "Zig",
      "href": "languages/zig.html"
    },
    {
      "text": "Developing Zed",
      "href": "development.html"
    },
    {
      "text": "Developing Zed",
      "href": "development.html"
    },
    {
      "text": "macOS",
      "href": "development/macos.html"
    },
    {
      "text": "Linux",
      "href": "development/linux.html"
    },
    {
      "text": "Windows",
      "href": "development/windows.html"
    },
    {
      "text": "FreeBSD",
      "href": "development/freebsd.html"
    },
    {
      "text": "Local Collaboration",
      "href": "development/local-collaboration.html"
    },
    {
      "text": "Using Debuggers",
      "href": "development/debuggers.html"
    },
    {
      "text": "Glossary",
      "href": "development/glossary.html"
    },
    {
      "text": "Release Process",
      "href": "development/releases.html"
    },
    {
      "text": "Debugging Crashes",
      "href": "development/debugging-crashes.html"
    }
  ],
  "page_toc": [],
  "scraped_at": "2025-09-06 14:11:28"
}